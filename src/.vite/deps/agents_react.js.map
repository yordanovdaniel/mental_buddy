{
  "version": 3,
  "sources": ["../../node_modules/partysocket/src/ws.ts", "../../node_modules/partysocket/src/index.ts", "../../node_modules/partysocket/src/use-handlers.ts", "../../node_modules/partysocket/src/use-socket.ts", "../../node_modules/partysocket/src/use-ws.ts", "../../node_modules/partysocket/src/react.ts", "../../node_modules/agents/src/react.tsx"],
  "sourcesContent": ["// TODO: lose this eslint-disable\n\n/*!\n * Reconnecting WebSocket\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\n * https://github.com/pladaria/reconnecting-websocket\n * License MIT\n */\n\nimport type { TypedEventTarget } from \"./type-helper\";\n\nif (!globalThis.EventTarget || !globalThis.Event) {\n  console.error(`\n  PartySocket requires a global 'EventTarget' class to be available!\n  You can polyfill this global by adding this to your code before any partysocket imports: \n  \n  \\`\\`\\`\n  import 'partysocket/event-target-polyfill';\n  \\`\\`\\`\n  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.\n`);\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  // biome-ignore lint/suspicious/noExplicitAny: vibes\n  constructor(error: Error, target: any) {\n    super(\"error\", target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  constructor(code = 1000, reason = \"\", target: any) {\n    super(\"close\", target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nconst Events = {\n  Event,\n  ErrorEvent,\n  CloseEvent\n};\n\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction cloneEventBrowser(e: Event) {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  return new (e as any).constructor(e.type, e) as Event;\n}\n\nfunction cloneEventNode(e: Event) {\n  if (\"data\" in e) {\n    const evt = new MessageEvent(e.type, e);\n    return evt;\n  }\n\n  if (\"code\" in e || \"reason\" in e) {\n    const evt = new CloseEvent(\n      // @ts-expect-error we need to fix event/listener types\n      (e.code || 1999) as number,\n      // @ts-expect-error we need to fix event/listener types\n      (e.reason || \"unknown reason\") as string,\n      e\n    );\n    return evt;\n  }\n\n  if (\"error\" in e) {\n    const evt = new ErrorEvent(e.error as Error, e);\n    return evt;\n  }\n\n  const evt = new Event(e.type, e);\n  return evt;\n}\n\nconst isNode =\n  typeof process !== \"undefined\" &&\n  typeof process.versions?.node !== \"undefined\" &&\n  typeof document === \"undefined\";\n\nconst cloneEvent = isNode ? cloneEventNode : cloneEventBrowser;\n\nexport type Options = {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  WebSocket?: any;\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  minUptime?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  maxEnqueuedMessages?: number;\n  startClosed?: boolean;\n  debug?: boolean;\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  debugLogger?: (...args: any[]) => void;\n};\n\nconst DEFAULT = {\n  maxReconnectionDelay: 10000,\n  minReconnectionDelay: 1000 + Math.random() * 4000,\n  minUptime: 5000,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4000,\n  maxRetries: Number.POSITIVE_INFINITY,\n  maxEnqueuedMessages: Number.POSITIVE_INFINITY,\n  startClosed: false,\n  debug: false\n};\n\nlet didWarnAboutMissingWebSocket = false;\n\nexport type UrlProvider = string | (() => string) | (() => Promise<string>);\nexport type ProtocolsProvider =\n  | null\n  | string\n  | string[]\n  | (() => string | string[] | null)\n  | (() => Promise<string | string[] | null>);\n\nexport type Message = string | ArrayBuffer | Blob | ArrayBufferView;\n\nexport default class ReconnectingWebSocket extends (EventTarget as TypedEventTarget<WebSocketEventMap>) {\n  private _ws: WebSocket | undefined;\n  private _retryCount = -1;\n  private _uptimeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _connectTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _shouldReconnect = true;\n  private _connectLock = false;\n  private _binaryType: BinaryType = \"blob\";\n  private _closeCalled = false;\n  private _messageQueue: Message[] = [];\n\n  private _debugLogger = console.log.bind(console);\n\n  protected _url: UrlProvider;\n  protected _protocols?: ProtocolsProvider;\n  protected _options: Options;\n\n  constructor(\n    url: UrlProvider,\n    protocols?: ProtocolsProvider,\n    options: Options = {}\n  ) {\n    super();\n    this._url = url;\n    this._protocols = protocols;\n    this._options = options;\n    if (this._options.startClosed) {\n      this._shouldReconnect = false;\n    }\n    if (this._options.debugLogger) {\n      this._debugLogger = this._options.debugLogger;\n    }\n    this._connect();\n  }\n\n  static get CONNECTING() {\n    return 0;\n  }\n  static get OPEN() {\n    return 1;\n  }\n  static get CLOSING() {\n    return 2;\n  }\n  static get CLOSED() {\n    return 3;\n  }\n\n  get CONNECTING() {\n    return ReconnectingWebSocket.CONNECTING;\n  }\n  get OPEN() {\n    return ReconnectingWebSocket.OPEN;\n  }\n  get CLOSING() {\n    return ReconnectingWebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return ReconnectingWebSocket.CLOSED;\n  }\n\n  get binaryType() {\n    return this._ws ? this._ws.binaryType : this._binaryType;\n  }\n\n  set binaryType(value: BinaryType) {\n    this._binaryType = value;\n    if (this._ws) {\n      this._ws.binaryType = value;\n    }\n  }\n\n  /**\n   * Returns the number or connection retries\n   */\n  get retryCount(): number {\n    return Math.max(this._retryCount, 0);\n  }\n\n  /**\n   * The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   */\n  get bufferedAmount(): number {\n    const bytes = this._messageQueue.reduce((acc, message) => {\n      if (typeof message === \"string\") {\n        acc += message.length; // not byte size\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this._ws ? this._ws.bufferedAmount : 0);\n  }\n\n  /**\n   * The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions(): string {\n    return this._ws ? this._ws.extensions : \"\";\n  }\n\n  /**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object\n   */\n  get protocol(): string {\n    return this._ws ? this._ws.protocol : \"\";\n  }\n\n  /**\n   * The current state of the connection; this is one of the Ready state constants\n   */\n  get readyState(): number {\n    if (this._ws) {\n      return this._ws.readyState;\n    }\n    return this._options.startClosed\n      ? ReconnectingWebSocket.CLOSED\n      : ReconnectingWebSocket.CONNECTING;\n  }\n\n  /**\n   * The URL as resolved by the constructor\n   */\n  get url(): string {\n    return this._ws ? this._ws.url : \"\";\n  }\n\n  /**\n   * Whether the websocket object is now in reconnectable state\n   */\n  get shouldReconnect(): boolean {\n    return this._shouldReconnect;\n  }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\n   */\n  public onclose: ((event: CloseEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when an error occurs\n   */\n  public onerror: ((event: ErrorEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  public onmessage: ((event: MessageEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  public onopen: ((event: Event) => void) | null = null;\n\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the connection is already\n   * CLOSED, this method does nothing\n   */\n  public close(code = 1000, reason?: string) {\n    this._closeCalled = true;\n    this._shouldReconnect = false;\n    this._clearTimeouts();\n    if (!this._ws) {\n      this._debug(\"close enqueued: no ws instance\");\n      return;\n    }\n    if (this._ws.readyState === this.CLOSED) {\n      this._debug(\"close: already closed\");\n      return;\n    }\n    this._ws.close(code, reason);\n  }\n\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   */\n  public reconnect(code?: number, reason?: string) {\n    this._shouldReconnect = true;\n    this._closeCalled = false;\n    this._retryCount = -1;\n    if (!this._ws || this._ws.readyState === this.CLOSED) {\n      this._connect();\n    } else {\n      this._disconnect(code, reason);\n      this._connect();\n    }\n  }\n\n  /**\n   * Enqueue specified data to be transmitted to the server over the WebSocket connection\n   */\n  public send(data: Message) {\n    if (this._ws && this._ws.readyState === this.OPEN) {\n      this._debug(\"send\", data);\n      this._ws.send(data);\n    } else {\n      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } =\n        this._options;\n      if (this._messageQueue.length < maxEnqueuedMessages) {\n        this._debug(\"enqueue\", data);\n        this._messageQueue.push(data);\n      }\n    }\n  }\n\n  private _debug(...args: unknown[]) {\n    if (this._options.debug) {\n      this._debugLogger(\"RWS>\", ...args);\n    }\n  }\n\n  private _getNextDelay() {\n    const {\n      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,\n      minReconnectionDelay = DEFAULT.minReconnectionDelay,\n      maxReconnectionDelay = DEFAULT.maxReconnectionDelay\n    } = this._options;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay =\n        minReconnectionDelay *\n        reconnectionDelayGrowFactor ** (this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this._debug(\"next delay\", delay);\n    return delay;\n  }\n\n  private _wait(): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, this._getNextDelay());\n    });\n  }\n\n  private _getNextProtocols(\n    protocolsProvider: ProtocolsProvider | null\n  ): Promise<string | string[] | null> {\n    if (!protocolsProvider) return Promise.resolve(null);\n\n    if (\n      typeof protocolsProvider === \"string\" ||\n      Array.isArray(protocolsProvider)\n    ) {\n      return Promise.resolve(protocolsProvider);\n    }\n\n    if (typeof protocolsProvider === \"function\") {\n      const protocols = protocolsProvider();\n      if (!protocols) return Promise.resolve(null);\n\n      if (typeof protocols === \"string\" || Array.isArray(protocols)) {\n        return Promise.resolve(protocols);\n      }\n\n      // @ts-expect-error redundant check\n      if (protocols.then) {\n        return protocols;\n      }\n    }\n\n    throw Error(\"Invalid protocols\");\n  }\n\n  private _getNextUrl(urlProvider: UrlProvider): Promise<string> {\n    if (typeof urlProvider === \"string\") {\n      return Promise.resolve(urlProvider);\n    }\n    if (typeof urlProvider === \"function\") {\n      const url = urlProvider();\n      if (typeof url === \"string\") {\n        return Promise.resolve(url);\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-expect-error\n      if (url.then) {\n        return url;\n      }\n\n      // return url;\n    }\n    throw Error(\"Invalid URL\");\n  }\n\n  private _connect() {\n    if (this._connectLock || !this._shouldReconnect) {\n      return;\n    }\n    this._connectLock = true;\n\n    const {\n      maxRetries = DEFAULT.maxRetries,\n      connectionTimeout = DEFAULT.connectionTimeout\n    } = this._options;\n\n    if (this._retryCount >= maxRetries) {\n      this._debug(\"max retries reached\", this._retryCount, \">=\", maxRetries);\n      return;\n    }\n\n    this._retryCount++;\n\n    this._debug(\"connect\", this._retryCount);\n    this._removeListeners();\n\n    this._wait()\n      .then(() =>\n        Promise.all([\n          this._getNextUrl(this._url),\n          this._getNextProtocols(this._protocols || null)\n        ])\n      )\n      .then(([url, protocols]) => {\n        // close could be called before creating the ws\n        if (this._closeCalled) {\n          this._connectLock = false;\n          return;\n        }\n        if (\n          !this._options.WebSocket &&\n          typeof WebSocket === \"undefined\" &&\n          !didWarnAboutMissingWebSocket\n        ) {\n          console.error(`‼️ No WebSocket implementation available. You should define options.WebSocket. \n\nFor example, if you're using node.js, run \\`npm install ws\\`, and then in your code:\n\nimport PartySocket from 'partysocket';\nimport WS from 'ws';\n\nconst partysocket = new PartySocket({\n  host: \"127.0.0.1:1999\",\n  room: \"test-room\",\n  WebSocket: WS\n});\n\n`);\n          didWarnAboutMissingWebSocket = true;\n        }\n        const WS: typeof WebSocket = this._options.WebSocket || WebSocket;\n        this._debug(\"connect\", { url, protocols });\n        this._ws = protocols ? new WS(url, protocols) : new WS(url);\n\n        this._ws.binaryType = this._binaryType;\n        this._connectLock = false;\n        this._addListeners();\n\n        this._connectTimeout = setTimeout(\n          () => this._handleTimeout(),\n          connectionTimeout\n        );\n      })\n      // via https://github.com/pladaria/reconnecting-websocket/pull/166\n      .catch((err) => {\n        this._connectLock = false;\n        this._handleError(new Events.ErrorEvent(Error(err.message), this));\n      });\n  }\n\n  private _handleTimeout() {\n    this._debug(\"timeout event\");\n    this._handleError(new Events.ErrorEvent(Error(\"TIMEOUT\"), this));\n  }\n\n  private _disconnect(code = 1000, reason?: string) {\n    this._clearTimeouts();\n    if (!this._ws) {\n      return;\n    }\n    this._removeListeners();\n    try {\n      if (\n        this._ws.readyState === this.OPEN ||\n        this._ws.readyState === this.CONNECTING\n      ) {\n        this._ws.close(code, reason);\n      }\n      this._handleClose(new Events.CloseEvent(code, reason, this));\n    } catch (_error) {\n      // ignore\n    }\n  }\n\n  private _acceptOpen() {\n    this._debug(\"accept open\");\n    this._retryCount = 0;\n  }\n\n  private _handleOpen = (event: Event) => {\n    this._debug(\"open event\");\n    const { minUptime = DEFAULT.minUptime } = this._options;\n\n    clearTimeout(this._connectTimeout);\n    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);\n\n    assert(this._ws, \"WebSocket is not defined\");\n\n    this._ws.binaryType = this._binaryType;\n\n    // send enqueued messages (messages sent before websocket open event)\n    this._messageQueue.forEach((message) => {\n      this._ws?.send(message);\n    });\n    this._messageQueue = [];\n\n    if (this.onopen) {\n      this.onopen(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleMessage = (event: MessageEvent) => {\n    this._debug(\"message event\");\n\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleError = (event: ErrorEvent) => {\n    this._debug(\"error event\", event.message);\n    this._disconnect(\n      undefined,\n      event.message === \"TIMEOUT\" ? \"timeout\" : undefined\n    );\n\n    if (this.onerror) {\n      this.onerror(event);\n    }\n    this._debug(\"exec error listeners\");\n    this.dispatchEvent(cloneEvent(event));\n\n    this._connect();\n  };\n\n  private _handleClose = (event: CloseEvent) => {\n    this._debug(\"close event\");\n    this._clearTimeouts();\n\n    if (this._shouldReconnect) {\n      this._connect();\n    }\n\n    if (this.onclose) {\n      this.onclose(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _removeListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"removeListeners\");\n    this._ws.removeEventListener(\"open\", this._handleOpen);\n    this._ws.removeEventListener(\"close\", this._handleClose);\n    this._ws.removeEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listerner types\n    this._ws.removeEventListener(\"error\", this._handleError);\n  }\n\n  private _addListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"addListeners\");\n    this._ws.addEventListener(\"open\", this._handleOpen);\n    this._ws.addEventListener(\"close\", this._handleClose);\n    this._ws.addEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listener types\n    this._ws.addEventListener(\"error\", this._handleError);\n  }\n\n  private _clearTimeouts() {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._uptimeTimeout);\n  }\n}\n", "import ReconnectingWebSocket from \"./ws\";\n\nimport type * as RWS from \"./ws\";\n\ntype Maybe<T> = T | null | undefined;\ntype Params = Record<string, Maybe<string>>;\nconst valueIsNotNil = <T>(\n  keyValuePair: [string, Maybe<T>]\n): keyValuePair is [string, T] =>\n  keyValuePair[1] !== null && keyValuePair[1] !== undefined;\n\nexport type PartySocketOptions = Omit<RWS.Options, \"constructor\"> & {\n  id?: string; // the id of the client\n  host: string; // base url for the party\n  room?: string; // the room to connect to\n  party?: string; // the party to connect to (defaults to main)\n  basePath?: string; // the base path to use for the party\n  prefix?: string; // the prefix to use for the party\n  protocol?: \"ws\" | \"wss\";\n  protocols?: string[];\n  path?: string; // the path to connect to\n  query?: Params | (() => Params | Promise<Params>);\n  disableNameValidation?: boolean; // disable validation of party/room names\n  // headers\n};\n\nexport type PartyFetchOptions = {\n  host: string; // base url for the party\n  room: string; // the room to connect to\n  party?: string; // the party to fetch from (defaults to main)\n  basePath?: string; // the base path to use for the party\n  prefix?: string; // the prefix to use for the party\n  path?: string; // the path to fetch from\n  protocol?: \"http\" | \"https\";\n  query?: Params | (() => Params | Promise<Params>);\n  fetch?: typeof fetch;\n};\n\nfunction generateUUID(): string {\n  // Public Domain/MIT\n  if (crypto?.randomUUID) {\n    return crypto.randomUUID();\n  }\n  let d = Date.now(); //Timestamp\n  let d2 = (performance?.now && performance.now() * 1000) || 0; //Time in microseconds since page-load or 0 if unsupported\n  // biome-ignore lint/complexity/useArrowFunction: it's fine\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16; //random number between 0 and 16\n    if (d > 0) {\n      //Use timestamp until depleted\n      r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    } else {\n      //Use microseconds since page-load if supported\n      r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n    return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\nfunction getPartyInfo(\n  partySocketOptions: PartySocketOptions | PartyFetchOptions,\n  defaultProtocol: \"http\" | \"ws\",\n  defaultParams: Record<string, string> = {}\n) {\n  const {\n    host: rawHost,\n    path: rawPath,\n    protocol: rawProtocol,\n    room,\n    party,\n    basePath,\n    prefix,\n    query\n  } = partySocketOptions;\n\n  // strip the protocol from the beginning of `host` if any\n  let host = rawHost.replace(/^(http|https|ws|wss):\\/\\//, \"\");\n  // if user provided a trailing slash, remove it\n  if (host.endsWith(\"/\")) {\n    host = host.slice(0, -1);\n  }\n\n  if (rawPath?.startsWith(\"/\")) {\n    throw new Error(\"path must not start with a slash\");\n  }\n\n  const name = party ?? \"main\";\n  const path = rawPath ? `/${rawPath}` : \"\";\n  const protocol =\n    rawProtocol ||\n    (host.startsWith(\"localhost:\") ||\n    host.startsWith(\"127.0.0.1:\") ||\n    host.startsWith(\"192.168.\") ||\n    host.startsWith(\"10.\") ||\n    (host.startsWith(\"172.\") &&\n      host.split(\".\")[1] >= \"16\" &&\n      host.split(\".\")[1] <= \"31\") ||\n    host.startsWith(\"[::ffff:7f00:1]:\")\n      ? // http / ws\n        defaultProtocol\n      : // https / wss\n        `${defaultProtocol}s`);\n\n  const baseUrl = `${protocol}://${host}/${basePath || `${prefix || \"parties\"}/${name}/${room}`}${path}`;\n\n  const makeUrl = (query: Params = {}) =>\n    `${baseUrl}?${new URLSearchParams([\n      ...Object.entries(defaultParams),\n      ...Object.entries(query).filter(valueIsNotNil)\n    ])}`;\n\n  // allow urls to be defined as functions\n  const urlProvider =\n    typeof query === \"function\"\n      ? async () => makeUrl(await query())\n      : makeUrl(query);\n\n  return {\n    host,\n    path,\n    room,\n    name,\n    protocol,\n    partyUrl: baseUrl,\n    urlProvider\n  };\n}\n\n// things that nathanboktae/robust-websocket claims are better:\n// doesn't do anything in offline mode (?)\n// \"natively aware of error codes\"\n// can do custom reconnect strategies\n\n// TODO: incorporate the above notes\nexport default class PartySocket extends ReconnectingWebSocket {\n  _pk!: string;\n  _pkurl!: string;\n  name!: string;\n  room?: string;\n  host!: string;\n  path!: string;\n\n  constructor(readonly partySocketOptions: PartySocketOptions) {\n    const wsOptions = getWSOptions(partySocketOptions);\n\n    super(wsOptions.urlProvider, wsOptions.protocols, wsOptions.socketOptions);\n\n    this.setWSProperties(wsOptions);\n\n    if (!partySocketOptions.disableNameValidation) {\n      if (partySocketOptions.party?.includes(\"/\")) {\n        console.warn(\n          `PartySocket: party name \"${partySocketOptions.party}\" contains forward slash which may cause routing issues. Consider using a name without forward slashes or set disableNameValidation: true to bypass this warning.`\n        );\n      }\n      if (partySocketOptions.room?.includes(\"/\")) {\n        console.warn(\n          `PartySocket: room name \"${partySocketOptions.room}\" contains forward slash which may cause routing issues. Consider using a name without forward slashes or set disableNameValidation: true to bypass this warning.`\n        );\n      }\n    }\n  }\n\n  public updateProperties(partySocketOptions: Partial<PartySocketOptions>) {\n    const wsOptions = getWSOptions({\n      ...this.partySocketOptions,\n      ...partySocketOptions,\n      host: partySocketOptions.host ?? this.host,\n      room: partySocketOptions.room ?? this.room,\n      path: partySocketOptions.path ?? this.path\n    });\n\n    this._url = wsOptions.urlProvider;\n    this._protocols = wsOptions.protocols;\n    this._options = wsOptions.socketOptions;\n\n    this.setWSProperties(wsOptions);\n  }\n\n  private setWSProperties(wsOptions: ReturnType<typeof getWSOptions>) {\n    const { _pk, _pkurl, name, room, host, path } = wsOptions;\n\n    this._pk = _pk;\n    this._pkurl = _pkurl;\n    this.name = name;\n    this.room = room;\n    this.host = host;\n    this.path = path;\n  }\n\n  public reconnect(\n    code?: number | undefined,\n    reason?: string | undefined\n  ): void {\n    if (!this.room || !this.host) {\n      throw new Error(\n        \"The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor.\"\n      );\n    }\n    super.reconnect(code, reason);\n  }\n\n  get id() {\n    return this._pk;\n  }\n\n  /**\n   * Exposes the static PartyKit room URL without applying query parameters.\n   * To access the currently connected WebSocket url, use PartySocket#url.\n   */\n  get roomUrl(): string {\n    return this._pkurl;\n  }\n\n  // a `fetch` method that uses (almost) the same options as `PartySocket`\n  static async fetch(\n    options: PartyFetchOptions,\n    init?: RequestInit\n  ): Promise<Response> {\n    const party = getPartyInfo(options, \"http\");\n    const url =\n      typeof party.urlProvider === \"string\"\n        ? party.urlProvider\n        : await party.urlProvider();\n    const doFetch = options.fetch ?? fetch;\n    return doFetch(url, init);\n  }\n}\n\nexport { PartySocket };\n\nexport { ReconnectingWebSocket as WebSocket };\n\nfunction getWSOptions(partySocketOptions: PartySocketOptions) {\n  const {\n    id,\n    host: _host,\n    path: _path,\n    party: _party,\n    room: _room,\n    protocol: _protocol,\n    query: _query,\n    protocols,\n    ...socketOptions\n  } = partySocketOptions;\n\n  const _pk = id || generateUUID();\n  const party = getPartyInfo(partySocketOptions, \"ws\", { _pk });\n\n  return {\n    _pk: _pk,\n    _pkurl: party.partyUrl,\n    name: party.name,\n    room: party.room,\n    host: party.host,\n    path: party.path,\n    protocols: protocols,\n    socketOptions: socketOptions,\n    urlProvider: party.urlProvider\n  };\n}\n", "import { useEffect, useRef } from \"react\";\n\nimport type WebSocket from \"./ws\";\n\nexport type EventHandlerOptions = {\n  onOpen?: (event: WebSocketEventMap[\"open\"]) => void;\n  onMessage?: (event: WebSocketEventMap[\"message\"]) => void;\n  onClose?: (event: WebSocketEventMap[\"close\"]) => void;\n  onError?: (event: WebSocketEventMap[\"error\"]) => void;\n};\n\n/** Attaches event handlers to a WebSocket in a React Lifecycle-friendly way */\nexport const useAttachWebSocketEventHandlers = (\n  socket: WebSocket,\n  options: EventHandlerOptions\n) => {\n  const handlersRef = useRef(options);\n  handlersRef.current = options;\n\n  useEffect(() => {\n    const onOpen: EventHandlerOptions[\"onOpen\"] = (event) =>\n      handlersRef.current?.onOpen?.(event);\n    const onMessage: EventHandlerOptions[\"onMessage\"] = (event) =>\n      handlersRef.current?.onMessage?.(event);\n    const onClose: EventHandlerOptions[\"onClose\"] = (event) =>\n      handlersRef.current?.onClose?.(event);\n    const onError: EventHandlerOptions[\"onError\"] = (event) =>\n      handlersRef.current?.onError?.(event);\n\n    socket.addEventListener(\"open\", onOpen);\n    socket.addEventListener(\"close\", onClose);\n    socket.addEventListener(\"error\", onError);\n    socket.addEventListener(\"message\", onMessage);\n\n    return () => {\n      socket.removeEventListener(\"open\", onOpen);\n      socket.removeEventListener(\"close\", onClose);\n      socket.removeEventListener(\"error\", onError);\n      socket.removeEventListener(\"message\", onMessage);\n    };\n  }, [socket]);\n};\n", "import { useEffect, useMemo, useRef, useState } from \"react\";\n\nimport type WebSocket from \"./ws\";\nimport type { Options } from \"./ws\";\n\n/** When any of the option values are changed, we should reinitialize the socket */\nexport const getOptionsThatShouldCauseRestartWhenChanged = (\n  options: Options\n) => [\n  options.startClosed,\n  options.minUptime,\n  options.maxRetries,\n  options.connectionTimeout,\n  options.maxEnqueuedMessages,\n  options.maxReconnectionDelay,\n  options.minReconnectionDelay,\n  options.reconnectionDelayGrowFactor,\n  options.debug\n];\n\n/**\n * Initializes a PartySocket (or WebSocket) and keeps it stable across renders,\n * but reconnects and updates the reference when any of the connection args change.\n */\nexport function useStableSocket<T extends WebSocket, TOpts extends Options>({\n  options,\n  createSocket,\n  createSocketMemoKey: createOptionsMemoKey\n}: {\n  options: TOpts;\n  createSocket: (options: TOpts) => T;\n  createSocketMemoKey: (options: TOpts) => string;\n}) {\n  // ensure we only reconnect when necessary\n  const shouldReconnect = createOptionsMemoKey(options);\n  const socketOptions = useMemo(() => {\n    return options;\n  }, [shouldReconnect]);\n\n  // this is the socket we return\n  const [socket, setSocket] = useState<T>(() =>\n    // only connect on first mount\n    createSocket({ ...socketOptions, startClosed: true })\n  );\n\n  // keep track of the socket we initialized\n  const socketInitializedRef = useRef<T | null>(null);\n\n  // allow changing the socket factory without reconnecting\n  const createSocketRef = useRef(createSocket);\n  createSocketRef.current = createSocket;\n\n  // finally, initialize the socket\n  useEffect(() => {\n    // we haven't yet restarted the socket\n    if (socketInitializedRef.current === socket) {\n      // create new socket\n      const newSocket = createSocketRef.current({\n        ...socketOptions,\n        // when reconnecting because of options change, we always reconnect\n        // (startClosed only applies to initial mount)\n        startClosed: false\n      });\n\n      // update socket reference (this will cause the effect to run again)\n      setSocket(newSocket);\n    } else {\n      // if this is the first time we are running the hook, connect...\n      if (!socketInitializedRef.current && socketOptions.startClosed !== true) {\n        socket.reconnect();\n      }\n      // track initialized socket so we know not to do it again\n      socketInitializedRef.current = socket;\n      // close the old socket the next time the socket changes or we unmount\n      return () => {\n        socket.close();\n      };\n    }\n  }, [socket, socketOptions]);\n\n  return socket;\n}\n", "import { useAttachWebSocketEventHandlers } from \"./use-handlers\";\nimport {\n  getOptionsThatShouldCauseRestartWhenChanged,\n  useStableSocket\n} from \"./use-socket\";\nimport WebSocket from \"./ws\";\n\nimport type { EventHandlerOptions } from \"./use-handlers\";\nimport type { Options, ProtocolsProvider, UrlProvider } from \"./ws\";\n\ntype UseWebSocketOptions = Options & EventHandlerOptions;\n\n// A React hook that wraps PartySocket\nexport default function useWebSocket(\n  url: UrlProvider,\n  protocols?: ProtocolsProvider,\n  options: UseWebSocketOptions = {}\n) {\n  const socket = useStableSocket({\n    options,\n    createSocket: (options) => new WebSocket(url, protocols, options),\n    createSocketMemoKey: (options) =>\n      JSON.stringify([\n        // will reconnect if url or protocols are specified as a string.\n        // if they are functions, the WebSocket will handle reconnection\n        url,\n        protocols,\n        ...getOptionsThatShouldCauseRestartWhenChanged(options)\n      ])\n  });\n\n  useAttachWebSocketEventHandlers(socket, options);\n\n  return socket;\n}\n", "import PartySocket from \"./index\";\nimport { useAttachWebSocketEventHandlers } from \"./use-handlers\";\nimport {\n  getOptionsThatShouldCauseRestartWhenChanged,\n  useStableSocket\n} from \"./use-socket\";\n\nimport type { PartySocketOptions } from \"./index\";\nimport type { EventHandlerOptions } from \"./use-handlers\";\n\ntype UsePartySocketOptions = Omit<PartySocketOptions, \"host\"> &\n  EventHandlerOptions & {\n    host?: string | undefined;\n  };\n\n// A React hook that wraps PartySocket\nexport default function usePartySocket(options: UsePartySocketOptions) {\n  const { host, ...otherOptions } = options;\n\n  const socket = useStableSocket({\n    options: {\n      host:\n        host ||\n        (typeof window !== \"undefined\"\n          ? window.location.host\n          : \"dummy-domain.com\"),\n      ...otherOptions\n    },\n    createSocket: (options) => new PartySocket(options),\n    createSocketMemoKey: (options) =>\n      JSON.stringify([\n        // NOTE: if query is defined as a function, the socket\n        // won't reconnect when you change the function identity\n        options.query,\n        options.id,\n        options.host,\n        options.room,\n        options.party,\n        options.path,\n        options.protocol,\n        options.protocols,\n        options.basePath,\n        options.prefix,\n        ...getOptionsThatShouldCauseRestartWhenChanged(options)\n      ])\n  });\n\n  useAttachWebSocketEventHandlers(socket, options);\n\n  return socket;\n}\n\nexport { default as useWebSocket } from \"./use-ws\";\n\n// TODO: remove the default export in a future breaking change\nexport { usePartySocket };\n", "import type { PartySocket } from \"partysocket\";\nimport { usePartySocket } from \"partysocket/react\";\nimport { useCallback, useRef, use, useMemo, useEffect } from \"react\";\nimport type { Agent, MCPServersState, RPCRequest, RPCResponse } from \"./\";\nimport type { StreamOptions } from \"./client\";\nimport type { Method, RPCMethod } from \"./serializable\";\nimport { MessageType } from \"./ai-types\";\n\n/**\n * Convert a camelCase string to a kebab-case string\n * @param str The string to convert\n * @returns The kebab-case string\n */\nfunction camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\n\ntype QueryObject = Record<string, string | null>;\n\nconst queryCache = new Map<\n  unknown[],\n  {\n    promise: Promise<QueryObject>;\n    refCount: number;\n    expiresAt: number;\n    cacheTtl?: number;\n  }\n>();\n\nfunction arraysEqual(a: unknown[], b: unknown[]): boolean {\n  if (a === b) return true;\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; i++) {\n    if (!Object.is(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nfunction findCacheEntry(\n  targetKey: unknown[]\n): Promise<QueryObject> | undefined {\n  for (const [existingKey, entry] of queryCache.entries()) {\n    if (arraysEqual(existingKey, targetKey)) {\n      // Check if entry has expired\n      if (Date.now() > entry.expiresAt) {\n        queryCache.delete(existingKey);\n        return undefined;\n      }\n      entry.refCount++;\n      return entry.promise;\n    }\n  }\n  return undefined;\n}\n\nfunction setCacheEntry(\n  key: unknown[],\n  value: Promise<QueryObject>,\n  cacheTtl?: number\n): void {\n  // Remove any existing entry with matching members\n  for (const [existingKey] of queryCache.entries()) {\n    if (arraysEqual(existingKey, key)) {\n      queryCache.delete(existingKey);\n      break;\n    }\n  }\n\n  const expiresAt = cacheTtl\n    ? Date.now() + cacheTtl\n    : Date.now() + 5 * 60 * 1000; // Default 5 minutes\n  queryCache.set(key, { promise: value, refCount: 1, expiresAt, cacheTtl });\n}\n\nfunction decrementCacheEntry(targetKey: unknown[]): boolean {\n  for (const [existingKey, entry] of queryCache.entries()) {\n    if (arraysEqual(existingKey, targetKey)) {\n      entry.refCount--;\n      if (entry.refCount <= 0) {\n        queryCache.delete(existingKey);\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction createCacheKey(\n  agentNamespace: string,\n  name: string | undefined,\n  deps: unknown[]\n): unknown[] {\n  return [agentNamespace, name || \"default\", ...deps];\n}\n\n/**\n * Options for the useAgent hook\n * @template State Type of the Agent's state\n */\nexport type UseAgentOptions<State = unknown> = Omit<\n  Parameters<typeof usePartySocket>[0],\n  \"party\" | \"room\" | \"query\"\n> & {\n  /** Name of the agent to connect to */\n  agent: string;\n  /** Name of the specific Agent instance */\n  name?: string;\n  /** Query parameters - can be static object or async function */\n  query?: QueryObject | (() => Promise<QueryObject>);\n  /** Dependencies for async query caching */\n  queryDeps?: unknown[];\n  /** Cache TTL in milliseconds for auth tokens/time-sensitive data */\n  cacheTtl?: number;\n  /** Called when the Agent's state is updated */\n  onStateUpdate?: (state: State, source: \"server\" | \"client\") => void;\n  /** Called when MCP server state is updated */\n  onMcpUpdate?: (mcpServers: MCPServersState) => void;\n};\n\ntype AllOptional<T> = T extends [infer A, ...infer R]\n  ? undefined extends A\n    ? AllOptional<R>\n    : false\n  : true; // no params means optional by default\n\ntype RPCMethods<T> = {\n  [K in keyof T as T[K] extends RPCMethod<T[K]> ? K : never]: RPCMethod<T[K]>;\n};\n\ntype OptionalParametersMethod<T extends RPCMethod> =\n  AllOptional<Parameters<T>> extends true ? T : never;\n\n// all methods of the Agent, excluding the ones that are declared in the base Agent class\n// biome-ignore lint: suppressions/parse\ntype AgentMethods<T> = Omit<RPCMethods<T>, keyof Agent<any, any>>;\n\ntype OptionalAgentMethods<T> = {\n  [K in keyof AgentMethods<T> as AgentMethods<T>[K] extends OptionalParametersMethod<\n    AgentMethods<T>[K]\n  >\n    ? K\n    : never]: OptionalParametersMethod<AgentMethods<T>[K]>;\n};\n\ntype RequiredAgentMethods<T> = Omit<\n  AgentMethods<T>,\n  keyof OptionalAgentMethods<T>\n>;\n\ntype AgentPromiseReturnType<T, K extends keyof AgentMethods<T>> =\n  // biome-ignore lint: suppressions/parse\n  ReturnType<AgentMethods<T>[K]> extends Promise<any>\n    ? ReturnType<AgentMethods<T>[K]>\n    : Promise<ReturnType<AgentMethods<T>[K]>>;\n\ntype OptionalArgsAgentMethodCall<AgentT> = <\n  K extends keyof OptionalAgentMethods<AgentT>\n>(\n  method: K,\n  args?: Parameters<OptionalAgentMethods<AgentT>[K]>,\n  streamOptions?: StreamOptions\n) => AgentPromiseReturnType<AgentT, K>;\n\ntype RequiredArgsAgentMethodCall<AgentT> = <\n  K extends keyof RequiredAgentMethods<AgentT>\n>(\n  method: K,\n  args: Parameters<RequiredAgentMethods<AgentT>[K]>,\n  streamOptions?: StreamOptions\n) => AgentPromiseReturnType<AgentT, K>;\n\ntype AgentMethodCall<AgentT> = OptionalArgsAgentMethodCall<AgentT> &\n  RequiredArgsAgentMethodCall<AgentT>;\n\ntype UntypedAgentMethodCall = <T = unknown>(\n  method: string,\n  args?: unknown[],\n  streamOptions?: StreamOptions\n) => Promise<T>;\n\ntype AgentStub<T> = {\n  [K in keyof AgentMethods<T>]: (\n    ...args: Parameters<AgentMethods<T>[K]>\n  ) => AgentPromiseReturnType<AgentMethods<T>, K>;\n};\n\n// we neet to use Method instead of RPCMethod here for retro-compatibility\ntype UntypedAgentStub = Record<string, Method>;\n\n/**\n * React hook for connecting to an Agent\n */\nexport function useAgent<State = unknown>(\n  options: UseAgentOptions<State>\n): PartySocket & {\n  agent: string;\n  name: string;\n  setState: (state: State) => void;\n  call: UntypedAgentMethodCall;\n  stub: UntypedAgentStub;\n};\nexport function useAgent<\n  AgentT extends {\n    get state(): State;\n  },\n  State\n>(\n  options: UseAgentOptions<State>\n): PartySocket & {\n  agent: string;\n  name: string;\n  setState: (state: State) => void;\n  call: AgentMethodCall<AgentT>;\n  stub: AgentStub<AgentT>;\n};\nexport function useAgent<State>(\n  options: UseAgentOptions<unknown>\n): PartySocket & {\n  agent: string;\n  name: string;\n  setState: (state: State) => void;\n  call: UntypedAgentMethodCall | AgentMethodCall<unknown>;\n  stub: UntypedAgentStub;\n} {\n  const agentNamespace = camelCaseToKebabCase(options.agent);\n  const { query, queryDeps, cacheTtl, ...restOptions } = options;\n\n  // Keep track of pending RPC calls\n  const pendingCallsRef = useRef(\n    new Map<\n      string,\n      {\n        resolve: (value: unknown) => void;\n        reject: (error: Error) => void;\n        stream?: StreamOptions;\n      }\n    >()\n  );\n\n  // Handle both sync and async query patterns\n  const cacheKey = useMemo(() => {\n    const deps = queryDeps || [];\n    return createCacheKey(agentNamespace, options.name, deps);\n  }, [agentNamespace, options.name, queryDeps]);\n\n  const queryPromise = useMemo(() => {\n    if (!query || typeof query !== \"function\") {\n      return null;\n    }\n\n    const existingPromise = findCacheEntry(cacheKey);\n    if (existingPromise) {\n      return existingPromise;\n    }\n\n    const promise = query().catch((error) => {\n      console.error(\n        `[useAgent] Query failed for agent \"${options.agent}\":`,\n        error\n      );\n      decrementCacheEntry(cacheKey); // Remove failed promise from cache\n      throw error; // Re-throw for Suspense error boundary\n    });\n\n    setCacheEntry(cacheKey, promise, cacheTtl);\n\n    return promise;\n  }, [cacheKey, query, options.agent, cacheTtl]);\n\n  let resolvedQuery: QueryObject | undefined;\n\n  if (query) {\n    if (typeof query === \"function\") {\n      // Use React's use() to resolve the promise\n      const queryResult = use(queryPromise!);\n\n      // Check for non-primitive values and warn\n      if (queryResult) {\n        for (const [key, value] of Object.entries(queryResult)) {\n          if (\n            value !== null &&\n            value !== undefined &&\n            typeof value !== \"string\" &&\n            typeof value !== \"number\" &&\n            typeof value !== \"boolean\"\n          ) {\n            console.warn(\n              `[useAgent] Query parameter \"${key}\" is an object and will be converted to \"[object Object]\". ` +\n                \"Query parameters should be string, number, boolean, or null.\"\n            );\n          }\n        }\n        resolvedQuery = queryResult;\n      }\n    } else {\n      // Sync query - use directly\n      resolvedQuery = query;\n    }\n  }\n\n  // Cleanup cache on unmount\n  useEffect(() => {\n    return () => {\n      if (queryPromise) {\n        decrementCacheEntry(cacheKey);\n      }\n    };\n  }, [cacheKey, queryPromise]);\n\n  const agent = usePartySocket({\n    party: agentNamespace,\n    prefix: \"agents\",\n    room: options.name || \"default\",\n    query: resolvedQuery,\n    ...restOptions,\n    onMessage: (message) => {\n      if (typeof message.data === \"string\") {\n        let parsedMessage: Record<string, unknown>;\n        try {\n          parsedMessage = JSON.parse(message.data);\n        } catch (_error) {\n          // silently ignore invalid messages for now\n          // TODO: log errors with log levels\n          return options.onMessage?.(message);\n        }\n        if (parsedMessage.type === MessageType.CF_AGENT_STATE) {\n          options.onStateUpdate?.(parsedMessage.state as State, \"server\");\n          return;\n        }\n        if (parsedMessage.type === MessageType.CF_AGENT_MCP_SERVERS) {\n          options.onMcpUpdate?.(parsedMessage.mcp as MCPServersState);\n          return;\n        }\n        if (parsedMessage.type === MessageType.RPC) {\n          const response = parsedMessage as RPCResponse;\n          const pending = pendingCallsRef.current.get(response.id);\n          if (!pending) return;\n\n          if (!response.success) {\n            pending.reject(new Error(response.error));\n            pendingCallsRef.current.delete(response.id);\n            pending.stream?.onError?.(response.error);\n            return;\n          }\n\n          // Handle streaming responses\n          if (\"done\" in response) {\n            if (response.done) {\n              pending.resolve(response.result);\n              pendingCallsRef.current.delete(response.id);\n              pending.stream?.onDone?.(response.result);\n            } else {\n              pending.stream?.onChunk?.(response.result);\n            }\n          } else {\n            // Non-streaming response\n            pending.resolve(response.result);\n            pendingCallsRef.current.delete(response.id);\n          }\n          return;\n        }\n      }\n      options.onMessage?.(message);\n    }\n  }) as PartySocket & {\n    agent: string;\n    name: string;\n    setState: (state: State) => void;\n    call: UntypedAgentMethodCall;\n    stub: UntypedAgentStub;\n  };\n  // Create the call method\n  const call = useCallback(\n    <T = unknown,>(\n      method: string,\n      args: unknown[] = [],\n      streamOptions?: StreamOptions\n    ): Promise<T> => {\n      return new Promise((resolve, reject) => {\n        const id = Math.random().toString(36).slice(2);\n        pendingCallsRef.current.set(id, {\n          reject,\n          resolve: resolve as (value: unknown) => void,\n          stream: streamOptions\n        });\n\n        const request: RPCRequest = {\n          args,\n          id,\n          method,\n          type: MessageType.RPC\n        };\n\n        agent.send(JSON.stringify(request));\n      });\n    },\n    [agent]\n  );\n\n  agent.setState = (state: State) => {\n    agent.send(JSON.stringify({ state, type: MessageType.CF_AGENT_STATE }));\n    options.onStateUpdate?.(state, \"client\");\n  };\n\n  agent.call = call;\n  agent.agent = agentNamespace;\n  agent.name = options.name || \"default\";\n  // biome-ignore lint: suppressions/parse\n  agent.stub = new Proxy<any>(\n    {},\n    {\n      get: (_target, method) => {\n        return (...args: unknown[]) => {\n          return call(method as string, args);\n        };\n      }\n    }\n  );\n\n  // warn if agent isn't in lowercase\n  if (agent.agent !== agent.agent.toLowerCase()) {\n    console.warn(\n      `Agent name: ${agent.agent} should probably be in lowercase. Received: ${agent.agent}`\n    );\n  }\n\n  return agent;\n}\n"],
  "mappings": "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",
  "names": ["evt", "_a", "query", "_a", "import_react", "_a", "useEffect", "useRef2", "useEffect2", "options", "options", "resolvedQuery: QueryObject | undefined", "parsedMessage: Record<string, unknown>", "request: RPCRequest"]
}
